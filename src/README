itamarleva,joshuakol
322467440,318135340

1)



2)
    1. TreeMap<Double, TreeSet<Character>>: We used this data structure in the SubImgCharMatcher class, the keys are
    are double brightness value of char, and the value of the TreeMap is a TreeSet<Character> containing all chars
    mapped with this brightness value. It's important to emphasize that our implementation contains the char brightness
    value before it was linearly stretched, therefore allowing us to implement addChar and removeChar in O(log^2(n)).The
    reason for that being, calculation of charBrightness is O(1), and adding/removing to BST is O(log^2(n)). We used
    this because it's ordered, therefore when there is a collision for finding multiple chars with the same brightness,
    we can access the lowest char value in O(1).

    2. HashSet<Character>:
    We implemented two synchronized HashSet<Character> in our AsciiArtSingleton class representing added chars and
    removed chars, in a way that when trying to add a char it will check if the char is in the removed set and remove it
    from there if it's there, otherwise it will add it to the 'added' charset and the other way around as well, in order
    to keep track of our previous charset that was run, and therefore if before the next run, the charset remains the
    same after all the user's manipulations, if the resolution also stayed the same, we will use the previous run's
    resultImage.

    3. TreeSet<Character>:
    We used this data structure in Shell class to contain our charset, allowing us to add and remove each character in
    O(log(n)), and print all characters in a sorted way, instead of sorting a HashSet causing it to be O(nlogn);

3)
    In order to handle illegal user inputs, we threw IllegalArgumentException with a informative message for the user.
    We created in our Constants class a static method for handling the desired informative message per case. We created
    a customized "BoundariesResolutionException" class that creates an exception that is thrown and caught in a case
    where the resolution is past the maximum/minimum limit. We also threw an IOException for an incorrect filename path.

4)
    We added 2 public getter methods, getMinCharBrightness and getMaxCharBrightness allowing the strategy classes to
    access these fields because they need them to perform the right round strategy.
    We added a public setter method, setRoundStrategy, allowing the shell to change the round strategy of the
    SubImgCharMatcher.

